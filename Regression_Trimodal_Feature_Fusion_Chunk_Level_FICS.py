# -*- coding: utf-8 -*-
"""Early_fusion_fics_kin_au_audio_3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1sGQL5FoiKlBh9X4tu4oGLxvNnHw8zxJy
"""

import numpy as np
import pandas as pd
import glob
import math
from sklearn.model_selection import train_test_split
from sklearn import linear_model
from math import sqrt
import matplotlib.pyplot as plt
from sklearn.model_selection import RepeatedKFold
from sklearn.metrics import mean_absolute_error
from sklearn import metrics
from sklearn.linear_model import LogisticRegression, LinearRegression
from sklearn.metrics import accuracy_score
from sklearn.metrics import f1_score
from sklearn.linear_model import Ridge
from sklearn.svm import SVR
from sklearn.decomposition import PCA
from keras.callbacks import ModelCheckpoint, Callback, EarlyStopping
import scipy.io as sio
import matplotlib as mpl
import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sns
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import regularizers
from tensorflow.keras.utils import to_categorical
from sklearn import preprocessing

from sklearn import preprocessing
from keras.models import Sequential
from keras.layers import Dense
from keras.layers import LSTM
from keras.layers import Dropout
from keras.models import Model
from keras.layers import Input, Dense, concatenate

def model_formation(chunk_size, seqLen):
  #LSTM Model
  callback = tf.keras.callbacks.EarlyStopping(monitor='val_loss', patience=5)
  #Left InputLSTM
  left_branch_input = Input(shape=(seqLen,16), name='Left_input')
  left_branch_output = LSTM(32, activation='tanh')(left_branch_input)
  #Middle Input LSTM
  middle_branch_input = Input(shape=(seqLen,17), name='middle_input')
  middle_branch_output = LSTM(32, activation='tanh')(middle_branch_input)
  #Right Input LSTM
  right_branch_input = Input(shape=(seqLen,23), name='Right_input')
  right_branch_output = LSTM(32, activation='tanh')(right_branch_input)
  #Merged Layer
  merged = concatenate([left_branch_output, middle_branch_output, right_branch_output], name='Concatenate')
  final_model_output = Dense(1, activation='linear')(merged)
  final_model = Model(inputs=[left_branch_input, middle_branch_input, right_branch_input], outputs=final_model_output,name='Final_output')
  opt = keras.optimizers.Adam(learning_rate=0.01) #Optimizer
  final_model.compile(optimizer = opt, loss = 'mean_absolute_error')
  final_model.summary()
  return final_model,callback

# onehot encoding of kineme sequence
def onehot_encoding(ks, nKineme):
    #print(ks)
    onehot_encoded = list()
    for k in ks:
        #print(k)
        vec = [0 for _ in range(nKineme)]
        vec[k-1] = 1
        onehot_encoded.append(vec)
        #print("Vector")
        #print(vec)
    return onehot_encoded


def ks_encoding(ks, nKineme):
    # ks is a numpy ndarray
    m, n = ks.shape #m=92, n=29
    #print(m, n)
    ks = ks.tolist() #converted to list
    encoded_features = np.asarray(
        [np.asarray(onehot_encoding(ks[i], nKineme)) for i in range(m)]
    )
    return encoded_features

def model_call(chunk_time, label, seqLen, final_model, callback):
    Audio_train_data_path = 'Chunks_for_AU_Kineme_Audio_With_Labels/Audio_chunk_'+ str(chunk_time)+'_train.npy'
    Audio_train_label_path = 'Chunks_for_AU_Kineme_Audio_With_Labels/Label_chunk_'+ str(chunk_time)+'_train_' + label+ '.npy'
    Audio_test_data_path = 'Chunks_for_AU_Kineme_Audio_With_Labels/Audio_chunk_'+ str(chunk_time)+'_test.npy'
    Audio_test_label_path = 'Chunks_for_AU_Kineme_Audio_With_Labels/Label_chunk_'+ str(chunk_time)+'_test_' + label+ '.npy'
    Audio_val_data_path = 'Chunks_for_AU_Kineme_Audio_With_Labels/Audio_chunk_'+ str(chunk_time)+'_val.npy'
    Audio_val_label_path = 'Chunks_for_AU_Kineme_Audio_With_Labels/Label_chunk_'+ str(chunk_time)+'_val_' + label+ '.npy'

    AU_train_data_path = 'Chunks_for_AU_Kineme_Audio_With_Labels/AU_chunk_'+ str(chunk_time)+'_train.npy'
    AU_test_data_path = 'Chunks_for_AU_Kineme_Audio_With_Labels/AU_chunk_'+ str(chunk_time)+'_test.npy'
    AU_val_data_path = 'Chunks_for_AU_Kineme_Audio_With_Labels/AU_chunk_'+ str(chunk_time)+'_val.npy'

    Kineme_train_data_path = 'Chunks_for_AU_Kineme_Audio_With_Labels/Kineme_chunk_'+ str(chunk_time)+'_train.npy'
    Kineme_test_data_path = 'Chunks_for_AU_Kineme_Audio_With_Labels/Kineme_chunk_'+ str(chunk_time)+'_test.npy'
    Kineme_val_data_path = 'Chunks_for_AU_Kineme_Audio_With_Labels/Kineme_chunk_'+ str(chunk_time)+'_val.npy'


    X_train_audio = np.load(Audio_train_data_path)  #path for AU train matrix
    y_train = np.load(Audio_train_label_path) #path for train labels
#     y_train = y_train[:,1]
#     y_train = [float(i) for i in y_train]
    y_train = np.around(y_train,3)

    X_val_audio = np.load(Audio_val_data_path) #path for AU validation matrix
    y_val = np.load(Audio_val_label_path) #path for validation labels
#     y_val = y_val[:,1]
#     y_val = [float(i) for i in y_val]
    y_val = np.around(y_val,3)

    X_test_audio = np.load(Audio_test_data_path) #path for AU test matrix
    y_test = np.load(Audio_test_label_path) #path for test labels
#     y_test = y_test[:,1]
#     y_test = [float(i) for i in y_test]
    y_test = np.around(y_test,3)

    X_train_au = np.load(AU_train_data_path)  #path for AU train matrix
    X_val_au = np.load(AU_val_data_path)  #path for AU train matrix
    X_test_au = np.load(AU_test_data_path)  #path for AU train matrix

    X_train_kineme = np.load(Kineme_train_data_path)  #path for AU train matrix
    X_val_kineme = np.load(Kineme_val_data_path)  #path for AU train matrix
    X_test_kineme = np.load(Kineme_test_data_path)  #path for AU train matrix
    
    scaler = preprocessing.StandardScaler().fit(X_train_audio)
    X_train = scaler.transform(X_train_audio)
    X_val = scaler.transform(X_val_audio)
    X_test = scaler.transform(X_test_audio)

    train_features,train_labels = X_train,y_train
    test_features, test_labels = X_test, y_test
    val_features, val_labels = X_val, y_val

    train_audio = train_features.reshape((train_features.shape[0], seqLen, 23)) 
    test_audio = test_features.reshape((test_features.shape[0], seqLen, 23))
    val_audio = val_features.reshape((val_features.shape[0], seqLen,23 ))

    train_au = X_train_au.reshape((X_train_au.shape[0], seqLen, 17)) 
    test_au = X_test_au.reshape((X_test_au.shape[0], seqLen, 17))
    val_au = X_val_au.reshape((X_val_au.shape[0], seqLen,17))

    train_kineme = ks_encoding(X_train_kineme, 16)
    test_kineme = ks_encoding(X_test_kineme, 16)
    val_kineme = ks_encoding(X_val_kineme, 16)

    print(train_audio.shape, test_audio.shape, val_audio.shape)
    print(train_au.shape, test_au.shape, val_au.shape)
    print(train_kineme.shape, test_kineme.shape, val_kineme.shape)
    
    zero_bias_history = final_model.fit([train_kineme, train_au, train_audio], train_labels, epochs = 250, batch_size = 100, validation_data = ([val_kineme, val_au, val_audio],val_labels), callbacks=[callback])

    y_pred_train = final_model.predict([train_kineme,train_au, train_audio])
    y_pred_train = np.around(y_pred_train,3)
    y_pred_test = final_model.predict([test_kineme,test_au, test_audio])
    y_pred_test = np.around(y_pred_test,3)
    train_mae = mean_absolute_error(train_labels, y_pred_train) ##mean squarred train error
    test_mae = mean_absolute_error(test_labels, y_pred_test) #mean squarred test error
    y_train = train_labels.reshape(-1,1)
    b = np.corrcoef(y_train.T,y_pred_train.T)
    train_PCC = b[0][1]
    y = test_labels.reshape(-1,1)
    a = np.corrcoef(y.T,y_pred_test.T)
    test_PCC = a[0][1]
    tr_acc = 1 - train_mae
    te_acc = 1-test_mae

    print("For label {0} and chunk_time {1}".format(label,chunk_time))
    print("Train-accuracy Test-accuracy Train-PCC Test-PCC")
    print(round(np.array(tr_acc).mean(),3),round(np.array(te_acc).mean(),3), round(np.array(train_PCC).mean(),3), round(np.array(test_PCC).mean(),3))

chunk_time = 7
label = 'O'
seqLen = 6
final_model,callback = model_formation(chunk_time, seqLen)
model_call(chunk_time, label, seqLen, final_model, callback)

chunk_time = 7
label = 'C'
seqLen = 6
final_model,callback = model_formation(chunk_time, seqLen)
model_call(chunk_time, label, seqLen, final_model, callback)

chunk_time = 7
label = 'E'
seqLen = 6
final_model,callback = model_formation(chunk_time, seqLen)
model_call(chunk_time, label, seqLen, final_model, callback)

chunk_time = 7
label = 'A'
seqLen = 6
final_model,callback = model_formation(chunk_time, seqLen)
model_call(chunk_time, label, seqLen, final_model, callback)

chunk_time = 7
label = 'N'
seqLen = 6
final_model,callback = model_formation(chunk_time, seqLen)
model_call(chunk_time, label, seqLen, final_model, callback)

